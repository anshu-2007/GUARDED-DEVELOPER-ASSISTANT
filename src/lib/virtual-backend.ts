import JSZip from 'jszip';
import { Policy, Intent, ExecutionResult } from './types';

// Mock OpenClaw Agent Logic
const parseInstructionToIntent = (instruction: string): Intent => {
  const lower = instruction.toLowerCase();
  
  if (lower.includes('delete') || lower.includes('remove')) {
    const parts = instruction.split(' ');
    const target = parts[parts.length - 1]; 
    return {
      action: 'delete',
      targetPath: target,
      reasoning: 'OpenClaw detected deletion intent',
    };
  }
  
  if (lower.includes('create') || lower.includes('add')) {
    const parts = instruction.split(' ');
    const target = parts[parts.length - 1];
    return {
      action: 'create',
      targetPath: target,
      content: '// Auto-generated by OpenClaw\nconsole.log("Hello World");',
      reasoning: 'OpenClaw detected creation intent',
    };
  }

  if (lower.includes('refactor') || lower.includes('modify') || lower.includes('update')) {
    const parts = instruction.split(' ');
    const target = parts[parts.length - 1];
    return {
      action: 'refactor',
      targetPath: target,
      reasoning: 'OpenClaw detected modification intent',
    };
  }

  return {
    action: 'unknown',
    targetPath: '',
    reasoning: 'OpenClaw could not determine clear intent',
  };
};

export const executeVirtualTask = async (
  zipFile: File,
  instruction: string,
  policies: Policy,
  onProgress: (step: string, log: string) => void
): Promise<ExecutionResult> => {
  const logs: string[] = [];
  const startTime = performance.now();
  const steps = [
    { name: 'Parsing Instruction', status: 'pending' },
    { name: 'Validating Intent', status: 'pending' },
    { name: 'ArmorClaw Enforcement', status: 'pending' },
    { name: 'Sandboxed Execution', status: 'pending' },
  ] as any;

  const addLog = (msg: string) => {
    logs.push(msg);
    onProgress('log', msg);
  };

  try {
    // 1. Load ZIP
    addLog(`[SYSTEM] Initializing OpenClaw Sandbox...`);
    addLog(`[SYSTEM] Loading ZIP: ${zipFile.name}`);
    const zip = new JSZip();
    const loadedZip = await zip.loadAsync(zipFile);
    addLog(`[SUCCESS] ZIP loaded. ${Object.keys(loadedZip.files).length} files indexed.`);

    // 2. Parse Intent
    steps[0].status = 'processing';
    onProgress('step', '0');
    addLog(`[OPENCLAW] Parsing instruction: "${instruction}"...`);
    await new Promise(r => setTimeout(r, 800));
    
    const intent = parseInstructionToIntent(instruction);
    addLog(`[OPENCLAW] Intent identified: ${intent.action.toUpperCase()} on "${intent.targetPath}"`);
    steps[0].status = 'completed';

    // 3. Validate Intent (ArmorClaw)
    steps[1].status = 'processing';
    onProgress('step', '1');
    addLog(`[ARMORCLAW] Validating intent against active policies...`);
    await new Promise(r => setTimeout(r, 600));

    // Check Restricted Commands
    if (policies.restrictedCommands.includes(intent.action)) {
      addLog(`[ARMORCLAW] VIOLATION: Command "${intent.action}" is restricted.`);
      steps[1].status = 'failed';
      return { status: 'blocked', reason: `Command "${intent.action}" is restricted by policy.`, intent, logs, executionTime: performance.now() - startTime, steps };
    }

    steps[1].status = 'completed';

    // 4. Enforcement (ArmorClaw Deep Check)
    steps[2].status = 'processing';
    onProgress('step', '2');
    addLog(`[ARMORCLAW] Enforcing file system boundaries...`);
    await new Promise(r => setTimeout(r, 600));

    // Check Restricted Files
    if (policies.restrictedFiles.some(f => intent.targetPath.includes(f))) {
      addLog(`[ARMORCLAW] VIOLATION: Access to restricted file "${intent.targetPath}" denied.`);
      steps[2].status = 'failed';
      return { status: 'blocked', reason: `File "${intent.targetPath}" is restricted.`, intent, logs, executionTime: performance.now() - startTime, steps };
    }

    // Check Allowed Folders (if strict mode)
    // For this demo, we assume if it's not in restricted, it's okay, unless it violates allowed folders logic
    // Let's implement: if allowedFolders is not empty, target MUST start with one of them
    if (policies.allowedFolders.length > 0) {
      const isAllowed = policies.allowedFolders.some(folder => intent.targetPath.startsWith(folder));
      if (!isAllowed) {
        addLog(`[ARMORCLAW] VIOLATION: Target "${intent.targetPath}" is outside allowed folders: [${policies.allowedFolders.join(', ')}]`);
        steps[2].status = 'failed';
        return { status: 'blocked', reason: `Target outside allowed folders.`, intent, logs, executionTime: performance.now() - startTime, steps };
      }
    }

    // Check File Types
    const ext = intent.targetPath.includes('.') ? '.' + intent.targetPath.split('.').pop() : '';
    if (ext && policies.allowedFileTypes.length > 0 && !policies.allowedFileTypes.includes(ext)) {
      addLog(`[ARMORCLAW] VIOLATION: File type "${ext}" is not in allowed list.`);
      steps[2].status = 'failed';
      return { status: 'blocked', reason: `File type "${ext}" not allowed.`, intent, logs, executionTime: performance.now() - startTime, steps };
    }

    steps[2].status = 'completed';

    // 5. Execution
    steps[3].status = 'processing';
    onProgress('step', '3');
    addLog(`[SANDBOX] Executing action safely...`);
    await new Promise(r => setTimeout(r, 1000));

    if (intent.action === 'delete') {
        loadedZip.remove(intent.targetPath);
        addLog(`[SANDBOX] Removed: ${intent.targetPath}`);
    } else if (intent.action === 'create') {
        loadedZip.file(intent.targetPath, intent.content || '');
        addLog(`[SANDBOX] Created: ${intent.targetPath}`);
    } else if (intent.action === 'refactor') {
        const file = loadedZip.file(intent.targetPath);
        if (file) {
            const content = await file.async('string');
            loadedZip.file(intent.targetPath, content + '\n// Refactored by Guarded Developer Assistant\n');
            addLog(`[SANDBOX] Modified: ${intent.targetPath}`);
        } else {
            addLog(`[WARN] File not found: ${intent.targetPath}`);
        }
    }

    steps[3].status = 'completed';

    // Finalize
    addLog(`[SYSTEM] Re-packaging ZIP...`);
    const modifiedBlob = await loadedZip.generateAsync({ type: 'blob' });
    addLog(`[SUCCESS] Execution complete. Output size: ${(modifiedBlob.size / 1024).toFixed(2)} KB`);

    return {
      status: 'allowed',
      intent,
      logs,
      modifiedZip: modifiedBlob,
      executionTime: performance.now() - startTime,
      steps
    };

  } catch (error) {
    addLog(`[ERROR] System Failure: ${(error as Error).message}`);
    return {
      status: 'error',
      reason: (error as Error).message,
      intent: { action: 'unknown', targetPath: '', reasoning: 'Error' },
      logs,
      executionTime: performance.now() - startTime,
      steps
    };
  }
};
